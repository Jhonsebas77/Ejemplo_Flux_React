{
  "_args": [
    [
      {
        "raw": "reflux@^5.0.4",
        "scope": null,
        "escapedName": "reflux",
        "name": "reflux",
        "rawSpec": "^5.0.4",
        "spec": ">=5.0.4 <6.0.0",
        "type": "range"
      },
      "/Volumes/ARCHIVOS/Dropbox/Fruticola de Colombia/Desarrollos/ReactNative/Proyectos/Ejemplo_Flux_React"
    ]
  ],
  "_from": "reflux@>=5.0.4 <6.0.0",
  "_id": "reflux@5.0.4",
  "_inCache": true,
  "_location": "/reflux",
  "_nodeVersion": "4.5.0",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/reflux-5.0.4.tgz_1481181847973_0.05679431417956948"
  },
  "_npmUser": {
    "name": "bryangrezeszak",
    "email": "bryangrezeszak@mail.com"
  },
  "_npmVersion": "3.8.9",
  "_phantomChildren": {},
  "_requested": {
    "raw": "reflux@^5.0.4",
    "scope": null,
    "escapedName": "reflux",
    "name": "reflux",
    "rawSpec": "^5.0.4",
    "spec": ">=5.0.4 <6.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/reflux/-/reflux-5.0.4.tgz",
  "_shasum": "256c869031fd3d9f9483489ea75b4d7c1e69cbe0",
  "_shrinkwrap": null,
  "_spec": "reflux@^5.0.4",
  "_where": "/Volumes/ARCHIVOS/Dropbox/Fruticola de Colombia/Desarrollos/ReactNative/Proyectos/Ejemplo_Flux_React",
  "author": {
    "name": "Mikael Brassman"
  },
  "bugs": {
    "url": "https://github.com/reflux/refluxjs/issues"
  },
  "dependencies": {
    "eventemitter3": "^1.1.1",
    "reflux-core": "^0.4.2"
  },
  "description": "A simple library for uni-directional dataflow application architecture inspired by ReactJS Flux",
  "devDependencies": {
    "benchmark": "^1.0.0",
    "browserify": "~10.2.3",
    "chai": "latest",
    "chai-as-promised": "latest",
    "es6-promise": "^2.3.0",
    "grunt": "^0.4.5",
    "grunt-browserify": "3.8.0",
    "grunt-cli": "^0.1.13",
    "grunt-contrib-jshint": "^0.11.2",
    "grunt-contrib-uglify": "^0.5.0",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-karma": "latest",
    "grunt-mocha-test": "~0.12.7",
    "karma": "latest",
    "karma-browserify": "latest",
    "karma-commonjs": "latest",
    "karma-mocha": "latest",
    "karma-phantomjs-launcher": "latest",
    "karma-sauce-launcher": "latest",
    "karma-spec-reporter": "latest",
    "matchdep": "^0.3.0",
    "mocha": "latest",
    "q": "^1.0.1",
    "react-dom": "^15.0.2",
    "sinon": "^1.10.3"
  },
  "directories": {},
  "dist": {
    "shasum": "256c869031fd3d9f9483489ea75b4d7c1e69cbe0",
    "tarball": "https://registry.npmjs.org/reflux/-/reflux-5.0.4.tgz"
  },
  "gitHead": "248991eda968948c3632154973d7a685b0b78640",
  "homepage": "https://github.com/reflux/refluxjs#readme",
  "keywords": [
    "reflux",
    "react",
    "flux",
    "architecture",
    "dataflow",
    "action",
    "event",
    "data"
  ],
  "license": "BSD-3-Clause",
  "main": "src/index.js",
  "maintainers": [
    {
      "name": "bryangrezeszak",
      "email": "bryangrezeszak@mail.com"
    },
    {
      "name": "devinivy",
      "email": "devin@bigroomstudios.com"
    },
    {
      "name": "spoike",
      "email": "mishakun+npm@gmail.com"
    }
  ],
  "name": "reflux",
  "optionalDependencies": {},
  "peerDependencies": {
    "react": "^15.0.2"
  },
  "readme": "# RefluxJS\r\n\r\nA simple library for unidirectional dataflow architecture inspired by ReactJS [Flux](http://facebook.github.io/react/blog/2014/05/06/flux.html).\r\n\r\n[![NPM Version][npm-image]][npm-url]\r\n[![NPM Downloads][downloads-image]][npm-url]\r\n[![Bower Version][bower-image]][bower-url]\r\n[![Dependencies][dependencies-image]][npm-url]\r\n[![Build Status][travis-image]][travis-url]\r\n[![Gratipay][gratipay-image]][gratipay-url]\r\n\r\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/refluxjs.svg)](https://saucelabs.com/u/refluxjs)\r\n\r\nYou can read an overview of Flux [here](https://facebook.github.io/flux/docs/overview.html), however the gist of it is to introduce a more functional programming style architecture by eschewing MVC like pattern and adopting a single data flow pattern.\r\n\r\n```\r\n╔═════════╗       ╔════════╗       ╔═════════════════╗\r\n║ Actions ║──────>║ Stores ║──────>║ View Components ║\r\n╚═════════╝       ╚════════╝       ╚═════════════════╝\r\n     ^                                      │\r\n     └──────────────────────────────────────┘\r\n\r\n```\r\n\r\nThe pattern is composed of actions and data stores, where actions initiate new data to pass through data stores before coming back to the view components again. If a view component has an event that needs to make a change in the application's data stores, they need to do so by signaling to the stores through the actions available.\r\n\r\nFeel free to open an issue on our [**discussion forum**](https://github.com/reflux/discuss) for **questions and general discussion**.  Here is a complete list of communication channels:\r\n\r\n1. The [discussion forum](https://github.com/reflux/discuss)\r\n2. [StackOverflow with the `refluxjs` tag](http://stackoverflow.com/questions/tagged/refluxjs)\r\n3. `#flux` channel on Reactiflux Discord group. [Sign up here](https://discord.gg/0ZcbPKXt5bYedEbN) for an account.\r\n4. [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/spoike/refluxjs?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\r\n5. [![Thinkful][thinkful-image]][thinkful-url]\r\n\r\nPlease use the [issue tracker](https://github.com/spoike/refluxjs/issues) only for bugs and feature requests.\r\n\r\nIf you don't want to use the React-specific API, or want to develop Reflux for your view engine framework of choice, have a look at [`reflux-core`](https://github.com/reflux/reflux-core).\r\n\r\n## Content\r\n\r\n- [Comparing RefluxJS with Facebook Flux](#comparing-refluxjs-with-facebook-flux)\r\n- [Examples](#examples)\r\n- [Extensions and Plugins](#extensions-and-plugins)\r\n- [Installation](#installation)\r\n- [Usage](#usage)\r\n     - [Actions](#creating-actions)\r\n     - [Stores](#creating-data-stores)\r\n     - [Component](#react-component-example)\r\n- [Advanced Usage](#advanced-usage)\r\n- [React ES6 Usage](#react-es6-usage)\r\n- [Colophon](#colophon)\r\n\r\n## Comparing RefluxJS with Facebook Flux\r\n\r\nThe goal of the refluxjs project is to get this architecture easily up and running in your web application, both client-side or server-side. There are some differences between how this project works and how Facebook's proposed Flux architecture works:\r\n\r\nYou can read more in this [blog post about React Flux vs Reflux](http://spoike.ghost.io/deconstructing-reactjss-flux/).\r\n\r\n### Similarities with Flux\r\n\r\nSome concepts are still in Reflux in comparison with Flux:\r\n\r\n* There are actions\r\n* There are data stores\r\n* The data flow is unidirectional\r\n\r\n### Differences with Flux\r\n\r\nReflux has refactored Flux to be a bit more dynamic and be more Functional Reactive Programming (FRP) friendly:\r\n\r\n* The singleton dispatcher is removed in favor for letting every action act as dispatcher instead.\r\n* Because actions are listenable, the stores may listen to them. Stores don't need to have big switch statements that do static type checking (of action types) with strings\r\n* Stores may listen to other stores, i.e. it is possible to create stores that can *aggregate data further*, similar to a map/reduce.\r\n* `waitFor` is replaced in favor to handle *serial* and *parallel* data flows:\r\n * **Aggregate data stores** (mentioned above) may listen to other stores in *serial*\r\n * **Joins** for joining listeners in *parallel*\r\n* *Action creators* are not needed because RefluxJS actions are functions that will pass on the payload they receive to anyone listening to them\r\n\r\n[Back to top](#content)\r\n\r\n## Examples\r\n\r\nYou can find some example projects at these locations:\r\n\r\n* [Todo Example Project](https://github.com/spoike/refluxjs-todo)\r\n* [Hacker News Clone](https://github.com/echenley/react-news) by echenley\r\n* [Another Todo Project with a Python backend](https://github.com/limelights/todo-reflux) by limelights\r\n* [Sample app with authentication, permissions, sidebar and editable collection](https://github.com/VladimirPal/react-flux-backbone)\r\n* [TodoMVC demonstrating Reflux + Angular](https://github.com/javamonn/Angular-TodoMVC-Redux)\r\n* [Sample blog by @akornatskyy](https://github.com/akornatskyy/sample-blog-react)\r\n\r\n[Back to top](#content)\r\n\r\n## Extensions and Plugins\r\n\r\n* [Cartiv](https://github.com/yonatanmn/cartiv) - new reactive interface based on Reflux\r\n* [reflux-promise](https://github.com/reflux/reflux-promise) - Extends reflux with Promises\r\n* [reflux-triggerable-mixin](https://github.com/jesstelford/reflux-triggerable-mixin) - Stores mixin adding `triggerable` syntax similar to `listenable`\r\n* [reflux-state-mixin](https://github.com/yonatanmn/reflux-state-mixin) - Stores mixin adding `state` syntax similar to React components.\r\n\r\n## Installation\r\n\r\nYou can currently install the package as a npm package or bower component.\r\n\r\n### NPM\r\n\r\nThe following command installs reflux as a npm package:\r\n\r\n    npm install reflux\r\n\r\n### Bower\r\n\r\nThe following command installs reflux as a bower component that can be used in the browser:\r\n\r\n    bower install reflux\r\n\t\r\nThen the files may be embedded in your html file via `bower_components/reflux/dist/reflux.js` or `bower_components/reflux/dist/reflux.min.js`.\r\n\r\n### CDN\r\n\r\nReflux is available at [jsdelivr](http://www.jsdelivr.com/#!refluxjs).  \r\njsdelivr [v5.0.1](https://cdn.jsdelivr.net/refluxjs/5.0.1/reflux.min.js)\r\n\r\n### ES5\r\n\r\nLike React, Reflux depends on an es5-shim for older browsers. The es5-shim.js from [kriskowal's es5-shim](https://github.com/kriskowal/es5-shim) provides everything required.\r\n\r\n[Back to top](#content)\r\n\r\n## Usage\r\n\r\n### Creating actions\r\n\r\nCreate an action by calling `Reflux.createAction` with an optional options object.\r\n\r\n```javascript\r\nvar statusUpdate = Reflux.createAction(options);\r\n```\r\n\r\nAn action is a [function object](http://en.wikipedia.org/wiki/Function_object) that can be invoked like any function.\r\n\r\n```javascript\r\nstatusUpdate(data); // Invokes the action statusUpdate\r\nstatusUpdate.triggerAsync(data); // same effect as above\r\n```\r\n\r\nIf `options.sync` is true, the functor will instead call `action.trigger` which is a synchronous operation. You can change `action.sync` during the lifetime of the action, and the following calls will honour that change.\r\n\r\nThere is also a convenience function for creating multiple actions.\r\n\r\n```javascript\r\nvar Actions = Reflux.createActions([\r\n    \"statusUpdate\",\r\n    \"statusEdited\",\r\n    \"statusAdded\"\r\n  ]);\r\n\r\n// Actions object now contains the actions\r\n// with the names given in the array above\r\n// that may be invoked as usual\r\n\r\nActions.statusUpdate();\r\n```\r\n\r\n#### Asynchronous actions\r\n\r\nFor actions that represent asynchronous operations (e.g. API calls), a few separate dataflows result from the operation. In the most typical case, we consider completion and failure of the operation. To create related actions for these dataflows, which you can then access as attributes, use `options.children`.\r\n\r\n```javascript\r\n// this creates 'load', 'load.completed' and 'load.failed'\r\nvar Actions = Reflux.createActions({\r\n    \"load\": {children: [\"completed\",\"failed\"]}\r\n});\r\n\r\n// when 'load' is triggered, call async operation and trigger related actions\r\nActions.load.listen( function() {\r\n    // By default, the listener is bound to the action\r\n    // so we can access child actions using 'this'\r\n    someAsyncOperation()\r\n        .then( this.completed )\r\n        .catch( this.failed );\r\n});\r\n```\r\n\r\nThere is a shorthand to define the `completed` and `failed` actions in the typical case: `options.asyncResult`. The following are equivalent:\r\n\r\n```javascript\r\ncreateAction({\r\n    children: [\"progressed\",\"completed\",\"failed\"]\r\n});\r\n\r\ncreateAction({\r\n    asyncResult: true,\r\n    children: [\"progressed\"]\r\n});\r\n```\r\n\r\n#### Action hooks\r\n\r\nThere are a couple of hooks available for each action.\r\n\r\n* `preEmit` - Is called before the action emits an event. It receives the arguments from the action invocation. If it returns something other than undefined, that will be used as arguments for `shouldEmit` and subsequent emission.\r\n\r\n* `shouldEmit` - Is called after `preEmit` and before the action emits an event. By default it returns `true` which will let the action emit the event. You may override this if you need to check the arguments that the action receives and see if it needs to emit the event.\r\n\r\nExample usage:\r\n\r\n```javascript\r\nActions.statusUpdate.preEmit = function() { console.log(arguments); };\r\nActions.statusUpdate.shouldEmit = function(value) {\r\n    return value > 0;\r\n};\r\n\r\nActions.statusUpdate(0);\r\nActions.statusUpdate(1);\r\n// Should output: 1\r\n```\r\n\r\nYou can also set the hooks by sending them in a definition object as you create the action:\r\n\r\n```javascript\r\nvar action = Reflux.createAction({\r\n    preEmit: function(){...},\r\n    shouldEmit: function(){...}\r\n});\r\n```\r\n\r\n#### Reflux.ActionMethods\r\n\r\nIf you would like to have a common set of methods available to all actions you can extend the `Reflux.ActionMethods` object, which is mixed into the actions when they are created.\r\n\r\nExample usage:\r\n\r\n```javascript\r\nReflux.ActionMethods.exampleMethod = function() { console.log(arguments); };\r\n\r\nActions.statusUpdate.exampleMethod('arg1');\r\n// Should output: 'arg1'\r\n```\r\n\r\n[Back to top](#content)\r\n\r\n### Creating data stores\r\n\r\nCreate a data store much like ReactJS's own `React.createClass` by passing a definition object to `Reflux.createStore`. You may set up all action listeners in the `init` function and register them by calling the store's own `listenTo` function.\r\n\r\n```javascript\r\n// Creates a DataStore\r\nvar statusStore = Reflux.createStore({\r\n\r\n    // Initial setup\r\n    init: function() {\r\n\r\n        // Register statusUpdate action\r\n        this.listenTo(statusUpdate, this.output);\r\n    },\r\n\r\n    // Callback\r\n    output: function(flag) {\r\n        var status = flag ? 'ONLINE' : 'OFFLINE';\r\n\r\n        // Pass on to listeners\r\n        this.trigger(status);\r\n    }\r\n\r\n});\r\n```\r\n\r\nIn the above example, whenever the action is called, the store's `output` callback will be called with whatever parameters were sent in the action. E.g. if the action is called as `statusUpdate(true)` then the flag argument in `output` function is `true`.\r\n\r\nA data store is a publisher much like the actions, so they too have the `preEmit` and `shouldEmit` hooks.\r\n\r\n#### Reflux.StoreMethods\r\n\r\nIf you would like to have a common set of methods available to all stores you can extend the `Reflux.StoreMethods` object, which is mixed into the stores when they are created.\r\n\r\nExample usage:\r\n\r\n```javascript\r\nReflux.StoreMethods.exampleMethod = function() { console.log(arguments); };\r\n\r\nstatusStore.exampleMethod('arg1');\r\n// Should output: 'arg1'\r\n```\r\n\r\n#### Mixins in stores\r\n\r\nJust as you can add mixins to React components, so it is possible to add your mixins to Store.\r\n\r\n```javascript\r\nvar MyMixin = { foo: function() { console.log('bar!'); } }\r\nvar Store = Reflux.createStore({\r\n    mixins: [MyMixin]\r\n});\r\nStore.foo(); // outputs \"bar!\" to console\r\n```\r\n\r\nMethods from mixins are available as well as the methods declared in the Store. So it's possible to access store's `this` from mixin, or methods of mixin from methods of store:\r\n\r\n```javascript\r\nvar MyMixin = { mixinMethod: function() { console.log(this.foo); } }\r\nvar Store = Reflux.createStore({\r\n    mixins: [MyMixin],\r\n    foo: 'bar!',\r\n    storeMethod: function() {\r\n        this.mixinMethod(); // outputs \"bar!\" to console\r\n    }\r\n});\r\n```\r\n\r\nA nice feature of mixins is that if a store is using multiple mixins and several mixins define the same lifecycle method (e.g. `init`, `preEmit`, `shouldEmit`), all of the lifecycle methods are guaranteed to be called.\r\n\r\n#### Listening to many actions at once\r\n\r\nSince it is a very common pattern to listen to all actions from a `createActions` call in a store `init` call, the store has a `listenToMany` function that takes an object of listenables. Instead of doing this:\r\n\r\n```javascript\r\nvar actions = Reflux.createActions([\"fireBall\",\"magicMissile\"]);\r\n\r\nvar Store = Reflux.createStore({\r\n    init: function() {\r\n        this.listenTo(actions.fireBall,this.onFireBall);\r\n        this.listenTo(actions.magicMissile,this.onMagicMissile);\r\n    },\r\n    onFireBall: function(){\r\n        // whoooosh!\r\n    },\r\n    onMagicMissile: function(){\r\n        // bzzzzapp!\r\n    }\r\n});\r\n```\r\n\r\n...you can do this:\r\n\r\n```javascript\r\nvar actions = Reflux.createActions([\"fireBall\",\"magicMissile\"]);\r\n\r\nvar Store = Reflux.createStore({\r\n    init: function() {\r\n        this.listenToMany(actions);\r\n    },\r\n    onFireBall: function(){\r\n        // whoooosh!\r\n    },\r\n    onMagicMissile: function(){\r\n        // bzzzzapp!\r\n    }\r\n});\r\n```\r\n\r\nThis will add listeners to all actions `actionName` who have a corresponding `onActionName` (or `actionName` if you prefer) method in the store. Thus if the `actions` object should also have included an `iceShard` spell, that would simply be ignored.\r\n\r\n#### The listenables shorthand\r\n\r\nTo make things more convenient still, if you give an object of actions to the `listenables` property of the store definition, that will be automatically passed to `listenToMany`. So the above example can be simplified even further:\r\n\r\n```javascript\r\nvar actions = Reflux.createActions([\"fireBall\",\"magicMissile\"]);\r\n\r\nvar Store = Reflux.createStore({\r\n    listenables: actions,\r\n    onFireBall: function(){\r\n        // whoooosh!\r\n    },\r\n    onMagicMissile: function(){\r\n        // bzzzzapp!\r\n    }\r\n});\r\n```\r\n\r\nThe `listenables` property can also be an array of such objects, in which case all of them will be sent to `listenToMany`. This allows you to do convenient things like this:\r\n\r\n```javascript\r\nvar Store = Reflux.createStore({\r\n    listenables: [require('./darkspells'),require('./lightspells'),{healthChange:require('./healthstore')}],\r\n    // rest redacted\r\n});\r\n```\r\n\r\n#### Listenables and asynchronous actions\r\n\r\nIf `options.children` is set, as in the example below, you can use `onActionSubaction` to add a listener to the child action. For example:\r\n\r\n```javascript\r\nvar Actions = Reflux.createActions({\r\n    \"load\": {children: [\"completed\", \"failed\"]}\r\n});\r\n\r\nfunction handleLoad(Action, Subaction){\r\n    console.log(\"The on\" + Action + Subaction + \" handler was called\");\r\n};\r\n\r\nvar Store = Reflux.createStore({\r\n    listenables: Actions,\r\n    onLoad: function() {\r\n        handleLoad(\"Load\");\r\n    },\r\n    onLoadCompleted: function() {\r\n        handleLoad(\"Load\", \"Completed\");\r\n    },\r\n    onLoadFailed: function() {\r\n        handleLoad(\"Load\", \"Failed\");\r\n    }\r\n});\r\n```\r\n\r\n\r\n### Listening to changes in data store\r\n\r\nIn your component, register to listen to changes in your data store like this:\r\n\r\n```javascript\r\n// Fairly simple view component that outputs to console\r\nfunction ConsoleComponent() {\r\n\r\n    // Registers a console logging callback to the statusStore updates\r\n    statusStore.listen(function(status) {\r\n        console.log('status: ', status);\r\n    });\r\n};\r\n\r\nvar consoleComponent = new ConsoleComponent();\r\n```\r\n\r\nInvoke actions as if they were functions:\r\n\r\n```javascript\r\nstatusUpdate(true);\r\nstatusUpdate(false);\r\n```\r\n\r\nWith the setup above this will output the following in the console:\r\n\r\n```\r\nstatus:  ONLINE\r\nstatus:  OFFLINE\r\n```\r\n\r\n[Back to top](#content)\r\n\r\n### React component example\r\n\r\nRegister your component to listen for changes in your data stores, preferably in the `componentDidMount` [lifecycle method](http://facebook.github.io/react/docs/component-specs.html) and unregister in the `componentWillUnmount`, like this:\r\n\r\n```javascript\r\nvar Status = React.createClass({\r\n    getInitialState: function() { },\r\n    onStatusChange: function(status) {\r\n        this.setState({\r\n            currentStatus: status\r\n        });\r\n    },\r\n    componentDidMount: function() {\r\n        this.unsubscribe = statusStore.listen(this.onStatusChange);\r\n    },\r\n    componentWillUnmount: function() {\r\n        this.unsubscribe();\r\n    },\r\n    render: function() {\r\n        // render specifics\r\n    }\r\n});\r\n```\r\n\r\nIt's also important to note that Reflux now supports [React ES6 style usage](#react-es6-usage) as well.\r\n\r\n#### Convenience mixin for React\r\n\r\nYou always need to unsubscribe components from observed actions and stores upon\r\nunmounting. To simplify this process you can use [mixins in React](http://facebook.github.io/react/docs/reusable-components.html#mixins). There is a convenience mixin available at `Reflux.ListenerMixin`. Using that, the above example can be written like thus:\r\n\r\n```javascript\r\nvar Status = React.createClass({\r\n    mixins: [Reflux.ListenerMixin],\r\n    onStatusChange: function(status) {\r\n        this.setState({\r\n            currentStatus: status\r\n        });\r\n    },\r\n    componentDidMount: function() {\r\n        this.listenTo(statusStore, this.onStatusChange);\r\n    },\r\n    render: function() {\r\n        // render specifics\r\n    }\r\n});\r\n```\r\n\r\nThe mixin provides the `listenTo` method for the React component, that works much like the one found in the Reflux's stores, and handles the listeners during mount and unmount for you. You also get the same `listenToMany` method as the store has.\r\n\r\n\r\n#### Using Reflux.listenTo\r\n\r\nIf you're not reliant on any special logic for the `this.listenTo` calls inside `componentDidMount`, you can instead use a call to `Reflux.listenTo` as a mixin. That will automatically set up the `componentDidMount` and the rest for you, as well as add the `ListenerMixin` functionality. With this our example above can be reduced even further:\r\n\r\n```javascript\r\nvar Status = React.createClass({\r\n    mixins: [Reflux.listenTo(statusStore,\"onStatusChange\")],\r\n    onStatusChange: function(status) {\r\n        this.setState({\r\n            currentStatus: status\r\n        });\r\n    },\r\n    render: function() {\r\n        // render using `this.state.currentStatus`\r\n    }\r\n});\r\n```\r\n\r\nYou can have multiple calls to `Reflux.listenTo` in the same `mixins` array.\r\n\r\nThere is also `Reflux.listenToMany` which works in exactly the same way, exposing `listener.listenToMany`.\r\n\r\n#### Using Reflux.connect\r\n\r\nIf all you want to do is update the state of your component to whatever the data store transmits, you can use `Reflux.connect(listener,stateKey)` as a mixin. The state is updated via `this.setState({<stateKey>:data})`. Here's the example above changed to use this syntax:\r\n\r\n```javascript\r\nvar Status = React.createClass({\r\n    mixins: [Reflux.connect(statusStore,\"currentStatus\")],\r\n    render: function() {\r\n        // render using `this.state.currentStatus`\r\n    }\r\n});\r\n```\r\n\r\nThe `Reflux.connect()` mixin will check the store for a `getInitialState` method. If found it will set the components `getInitialState`\r\n\r\n```javascript\r\nvar statusStore = Reflux.createStore({\r\n    getInitialState: function() {\r\n        return \"open\";\r\n    }\r\n});\r\n\r\nvar Status = React.createClass({\r\n    mixins: [Reflux.connect(statusStore,\"currentStatus\")],\r\n    render: function() {\r\n        // render using `this.state.currentStatus`\r\n        // this.state.currentStatus === \"open\"\r\n    }\r\n});\r\n```\r\n\r\n#### Using Reflux.connectFilter\r\n\r\n`Reflux.connectFilter` is used in a similar manner to `Reflux.connect`. Use the\r\n`connectFilter` mixin when you want only a subset of the items in a store. A\r\nblog written using Reflux would probably have a store with all posts in\r\nit. For an individual post page, you could use `Reflux.connectFilter` to\r\nfilter the posts to the post that's being viewed.\r\n\r\n```javascript\r\nvar PostView = React.createClass({\r\n    mixins: [Reflux.connectFilter(postStore, \"post\", function(posts) {\r\n        return posts.filter(function(post) {\r\n           return post.id === this.props.id;\r\n        }.bind(this))[0];\r\n    })],\r\n    render: function() {\r\n        // render using `this.state.post`\r\n    }\r\n});\r\n```\r\n\r\n### Listening to changes in other data stores (aggregate data stores)\r\n\r\nA store may listen to another store's change, making it possible to safely chain stores for aggregated data without affecting other parts of the application. A store may listen to other stores using the same `listenTo` function as with actions:\r\n\r\n```javascript\r\n// Creates a DataStore that listens to statusStore\r\nvar statusHistoryStore = Reflux.createStore({\r\n    init: function() {\r\n\r\n        // Register statusStore's changes\r\n        this.listenTo(statusStore, this.output);\r\n\r\n        this.history = [];\r\n    },\r\n\r\n    // Callback\r\n    output: function(statusString) {\r\n        this.history.push({\r\n            date: new Date(),\r\n            status: statusString\r\n        });\r\n        // Pass the data on to listeners\r\n        this.trigger(this.history);\r\n    }\r\n\r\n});\r\n```\r\n\r\n[Back to top](#content)\r\n\r\n## Advanced usage\r\n\r\n### Switching EventEmitter\r\n\r\nDon't like to use the EventEmitter provided? You can switch to another one, such as NodeJS's own like this:\r\n\r\n```javascript\r\n// Do this before creating actions or stores\r\n\r\nReflux.setEventEmitter(require('events').EventEmitter);\r\n```\r\n\r\n### Switching nextTick\r\n\r\nWhenever action functors are called, they return immediately through the use of `setTimeout` (`nextTick` function) internally.\r\n\r\nYou may switch out for your favorite `setTimeout`, `nextTick`, `setImmediate`, et al implementation:\r\n\r\n```javascript\r\n\r\n// node.js env\r\nReflux.nextTick(process.nextTick);\r\n```\r\n\r\nFor better alternative to `setTimeout`, you may opt to use the [`setImmediate` polyfill](https://github.com/YuzuJS/setImmediate), [`setImmediate2`](https://github.com/Katochimoto/setImmediate) or [`macrotask`](https://github.com/calvinmetcalf/macrotask).\r\n\r\n\r\n### Joining parallel listeners with composed listenables\r\n\r\nThe Reflux API contains `join` methods that makes it easy to aggregate publishers that emit events in parallel. This corresponds to the `waitFor` method in Flux.\r\n\r\n#### Argument tracking\r\n\r\nA join is triggered once all participating publishers have emitted at least once. The callback will be called with the data from the various emissions, in the same order as the publishers were listed when the join was created.\r\n\r\nThere are four join methods, each representing a different strategy to track the emission data:\r\n\r\n*    `joinLeading`: Only the first emission from each publisher is saved. Subsequent emissions by the same publisher before all others are finished are ignored.\r\n*    `joinTrailing`: If a publisher triggers twice, the second emission overwrites the first.\r\n*    `joinConcat`: An array of emission arguments are stored for each publisher.\r\n*    `joinStrict`: An error is thrown if a publisher emits twice before the join is completed.\r\n\r\nThe method signatures all look like this:\r\n\r\n```javascript\r\njoinXyz(...publisher,callback)\r\n```\r\n\r\nOnce a join is triggered it will reset, and thus it can trigger again when all publishers have emitted anew.\r\n\r\n#### Using the listener instance methods\r\n\r\nAll objects using the listener API (stores, React components using `ListenerMixin`, or other components using the `ListenerMethods`) gain access to the four join instance methods, named after the argument strategy. Here's an example saving the last emission from each publisher:\r\n\r\n```javascript\r\nvar gainHeroBadgeStore = Reflux.createStore({\r\n    init: function() {\r\n        this.joinTrailing(actions.disarmBomb, actions.saveHostage, actions.recoverData, this.triggerAsync);\r\n    }\r\n});\r\n\r\nactions.disarmBomb(\"warehouse\");\r\nactions.recoverData(\"seedyletter\");\r\nactions.disarmBomb(\"docks\");\r\nactions.saveHostage(\"offices\",3);\r\n// `gainHeroBadgeStore` will now asynchronously trigger `[[\"docks\"],[\"offices\",3],[\"seedyletter\"]]`.\r\n```\r\n\r\n#### Using the static methods\r\n\r\nSince it is rather common to have a store where the only purpose is to listen to a join and trigger when the join is completed, the join methods have static counterparts on the `Reflux` object which return stores listening to the requested join. Using them, the store in the example above could instead be created like this:\r\n\r\n```javascript\r\nvar gainHeroBadgeStore = Reflux.joinTrailing(actions.disarmBomb, actions.saveHostage, actions.recoverData);\r\n```\r\n\r\n### Sending initial state with the listenTo function\r\n\r\nThe `listenTo` function provided by the `Store` and the `ListenerMixin` has a third parameter that accepts a callback. This callback will be invoked when the listener is registered with whatever the `getInitialState` is returning.\r\n\r\n```javascript\r\nvar exampleStore = Reflux.createStore({\r\n    init: function() {},\r\n    getInitialState: function() {\r\n        return \"the initial data\";\r\n    }\r\n});\r\n\r\n// Anything that will listen to the example store\r\nthis.listenTo(exampleStore, onChangeCallback, initialCallback)\r\n\r\n// initialCallback will be invoked immediately with \"the initial data\" as first argument\r\n```\r\n\r\nRemember the `listenToMany` method? In case you use that with other stores, it supports `getInitialState`. That data is sent to the normal listening callback, or a `this.on<Listenablename>Default` method if that exists.\r\n\r\n[Back to top](#content)\r\n\r\n## React ES6 Usage\r\n\r\n### React ES6 component example\r\n\r\nReflux exposes `Reflux.Component` for class extension for easy creation of ES6 style React components that automatically has the state of one or more Reflux stores mixed into the React component state. In order to accomplish this you simply need use Reflux stores that start with a `state` property with an object holding the default state of the store's data (i.e. set `this.state = {my:\"defaults\"}` in the store's `init`) , then you need to set `this.store` (to 1 store) or `this.stores` (to an Array of stores) from within the constructor of the component. An example would look like this:\r\n\r\n```javascript\r\nclass MyComponent extends Reflux.Component // <- Reflux.Component instead of React.Component\r\n{\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {foo:'bar'}; // <- stays usable, so normal state usage can still happen\r\n        this.store = myStore; // <- the only thing needed to tie the store into this component\r\n    }\r\n\r\n    render() {\r\n        // `storeProp` is mixed in from the store, and reflects in the component state\r\n        return <p>From Store: {this.state.storeProp}, Foo: {this.state.foo}</p>;\r\n    }\r\n}\r\n```\r\n\r\nThe default states of the stores will be mixed in from the start, and any time the store does a `trigger` the triggered data will be mixed in to the component and it will re-render.\r\n\r\nA fully working example may look something like this:\r\n\r\n```javascript\r\nvar Actions = Reflux.createActions([\"increment\"]);\r\n\r\nvar counterStore = Reflux.createStore(\r\n{\r\n    listenables: Actions,\r\n    \r\n    init: function() {\r\n        this.state = {count:0};\r\n    },\r\n    \r\n    onIncrement: function(txt) {\r\n        this.state.count++;\r\n        this.trigger(this.state);\r\n    }\r\n});\r\n\r\nclass Counter extends Reflux.Component\r\n{\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n        this.store = counterStore;\r\n    }\r\n    \r\n    render() {\r\n        return <p>Count: {this.state.count}</p>;\r\n    }\r\n}\r\n\r\n\r\nReactDOM.render(\r\n    <Counter />,\r\n    document.getElementById('container')\r\n);\r\n\r\nsetInterval(Actions.increment, 1000);\r\n```\r\n\r\nNOTE: If you are also using `Reflux.Store` ES6 stores and updating them properly via their `setState` method then you may also choose to only mix in certain properties from the store(s) attached to a component, instead of all of them. To do this you may define `this.storeKeys` in the component's constructor and set it to an array of key names (strings) for properties you want mixed in from the attached stores. The component will then only mix in state object properties of those key names for any stores attached to it. If the store state is changed and none of the changed state involves the keys in `this.storeKeys` then the component will not change state at all nor re-render.\r\n\r\n```javascript\r\n//...\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n        this.store = MyStore;\r\n        this.storeKeys = ['color', 'height'];\r\n        // ^ will only include the color and height parts of MyStore's state\r\n    }\r\n//...\r\n```\r\n\r\n### Using ES6 Reflux Stores via Reflux.Store\r\n\r\nStores do not directly integrate within React like `Reflux.Component` needs to, so using a more idiomatic way to declare them is not necessary. However, it can be very useful when using the `Reflux.Component` style components. Therefore whenever `Reflux.Component` is exposed Reflux also exposes `Reflux.Store` which can be extended to make a class that wraps and acts as a reflux store but with an approach that is easier to implement into `Reflux.Component` classes.\r\n\r\nTo create one looks something like this:\r\n\r\n```javascript\r\nclass MyStore extends Reflux.Store\r\n{\r\n    constructor() {\r\n        super();\r\n        this.state = {foo:'bar'}; // <-- the store's default state\r\n    }\r\n}\r\n```\r\n\r\nThese act much like a normal store. You can use `this.listenTo`, `this.listenToMany`, etc. from within the constructor, and you can define things like a `this.listenables` property and it will automatically call `action` and `onAction` named methods on the class. It also exposes a `setState` method that you can use to modify your `state` property and automatically `trigger` the change:\r\n\r\n```javascript\r\nvar Actions = Reflux.createActions([\"increment\"]);\r\n\r\nclass CounterStore extends Reflux.Store\r\n{\r\n    constructor() {\r\n        super();\r\n        this.listenables = Actions;\r\n        this.state = {count:0};\r\n    }\r\n    \r\n    onIncrement() {\r\n        var cnt = this.state.count;\r\n        this.setState({count:cnt+1});\r\n    }\r\n}\r\n```\r\n\r\n`this.listenables` also accepts an array of actions in the event you want your store to listen to actions from other places as well:\r\n\r\n```javascript\r\nvar Actions1 = Reflux.createActions([\"increment\"]);\r\nvar Actions2 = Reflux.createActions([\"decrement\"]);\r\n\r\nclass CounterStore extends Reflux.Store\r\n{\r\n    constructor() {\r\n        super();\r\n        this.listenables = [Actions1, Actions2];\r\n        this.state = {count:0};\r\n    }\r\n    \r\n    onIncrement() {\r\n        var cnt = this.state.count;\r\n        this.setState({count:cnt+1});\r\n    }\r\n\r\n    onDecrement() {\r\n        var cnt = this.state.count;\r\n        this.setState({count:cnt-1});\r\n    }\r\n}\r\n```\r\n\r\nOne thing you may notice is that the original style `Reflux.createStore` creates an actual instance (as opposed to a class) which is what is assigned to `this.store` in the `Reflux.Component`. Extending `Reflux.Store` means you just have a class, not an instance of anything. Of course you can instantiate and use that store; however, if you just assign the class itself to `this.store` or `this.stores` in the `Reflux.Component` then it will automatically create a singleton instance of the store class (or use a previously created singleton instance of it if another component has already done so in its own construction). So, for example, to utilize the `Reflux.Store` store in the last example within a `Reflux.Component` class would look like this:\r\n\r\n```javascript\r\nclass Counter extends Reflux.Component\r\n{\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n        this.store = CounterStore; // <- just assign the class itself\r\n    }\r\n    \r\n    render() {\r\n        return <p>Count: {this.state.count}</p>;\r\n    }\r\n}\r\n```\r\n\r\n**Note!** `Reflux.Store` still works with instances of stores (i.e. the class must get intantiated). Assigning the class itself to `this.store` just allows Reflux to handle the instantiation and do some internal things that allow features like global state tracking. it does *not* mean that the class itself is the store. Internally Reflux creates and utilizes a singleton instance of the class. After mounting you may access that singleton instance of the class via `MyStoreClass.singleton`.\r\n\r\n#### Using Reflux.Store without a component\r\n\r\nWith to ability to do so much via global states (covered in the next section), and the fact that that functionality is tied to `Reflux.Store`, being able to properly utilize `Reflux.Store` on its own (without binding to a React component) becomes useful. However, just using `new MyStoreClass()` isn't enough, as it has to tie itself into the Reflux global state as a singleton. Therefore Reflux exposes an API for getting a properly globalized singleton instance of a `Reflux.Store` extended class without having to tie it to a React component. You do this via the following:\r\n\r\n```javascript\r\nvar mySingleton = Reflux.initializeGlobalStore(MyClassName);\r\n```\r\n\r\nWhen done this way the singleton instance of your `Reflux.Store` class can, externally, be used much like a non-ES6 store created via `Reflux.createStore` except with the advantages that it: 1) is written in the `Reflux.Store` ES6 syntax and 2) it ties in with the global state being tracked by Reflux.\r\n\r\nNote: your store _must_ be set up with an `id` to be used this way.\r\n\r\nNote: even after instantiating with `Reflux.initializeGlobalStore` you can still later assign the class name itself to `this.store` or `this.stores` in a `Reflux.Component`. The component will recognize that a singleton for the class has already been created and use that singleton.\r\n\r\n##### A deeper understanding:\r\n\r\nTo avoid confusion I want to better explain what `Reflux.initializeGlobalStore` is for on a deeper level. This is also a good section to read for people that just want a better understanding of working with `Reflux.Store` in general.\r\n\r\nWhen you define a store in ES6 `Reflux.Store` syntax you are creating a class, not an instance of a class. For Reflux to use that store internally an instance of the class must be created. But it's also important that only **one** instance of that store class get created (i.e. a singleton) so that each component using it is using the same store instance. That is why you're told to assign the class itself to `this.store` or `this.stores` in a `Reflux.Component`. Assigning an instance works...but if you assign the class itself then it can use its own internal logic to say *\"Is a singleton already made for this class? If yes, use that singleton. If not, then make it first, then use it.\"* therefore automatically making sure only one singleton instance is used everywhere. On top of that (if the class has an id) it also makes sure that the global state is aware of that store so that it can track it.\r\n\r\nThis works great as long as you're going to be using that store in a component. But what if you don't want to use it in any components?\r\n\r\nIf you don't care about the global state knowing about it and tracking it then it's easy. Since no components are using it then there's no chance of multiple store instances accidentally being created, so just use `var store = new MyStoreClass();` like any other class you'd be instantiating. If you wanted to be thorough and make your instance in the same singleton fashion as is done internally (just in case some later component decides to use that class without your knowledge) then you could go `var store = new MyStoreClass(); MyStoreClass.singleton = store;` and then any future component usage would know about, and use, that singleton instance.\r\n\r\nBut that still leaves a scenario out in the cold: needing to intantiate a store without it being attached to any components to handle it for you, but *also* wanting that store to be properly tracked by the global state. That is where `Reflux.initializeGlobalStore` can be used to create your singleton instance and handle what needs to be handled internally to track the global state. \r\n\r\nAnother possible scenario would be if you need to access the singleton instance of the store *before* the `componentWillMount` part of any component's lifecycle (which is where the component would set up the singleton). You can use `Reflux.initializeGlobalStore` to create a singleton that you can access sooner. You can *still* assign the class itself to `this.store` or `this.stores` in any components though! The component will know that a singleton has already been created and automatically use it, there is no need for you to manually track the singleton for the components just because you used `Reflux.initializeGlobalStore` in order to get access to that singleton sooner!\r\n\r\n#### Mapping Stores to Components with `mapStoreToState`\r\n\r\nReflux's ES6 stores and components work together fairly well in a very declarative syntax by simply assigning stores to components via the component's `this.store` and `this.stores` properties, and that functionality rounds itself out by adding some filtering ability with `this.storeKeys`. With enough thought given to architecture this can get you almost everything you need in a declarative syntax that is easy for you to write and others to read. Therefore it's highly suggested that you put the time into planning your architecture to be able to use those for connecting stores and components.\r\n\r\nHowever, there still exists a need to have deeper control and to be able to map stores to component states with your own custom logic in some cases. For that each `Reflux.Component` will have a `this.mapStoreToState` method. This is **completely separate** from the previously mentioned declarative side of things (such as `this.store`). That means you should not have the same store attached to a component both via `this.store` *and* using `this.mapStoreToState`, and also that this method is completely unaffected by `this.storeKeys`. These differing methods can both be used within a single component, they just shouldn't be both used for the *same store* within the same component.\r\n\r\nThis method takes 2 arguments: the `Reflux.Store` you want mapped to the component state (either the class itself or the singleton instance) and a mapping function supplied by you. The mapping function will be called any time the store instance's `setState` is used to change the state of the store. The mapping function takes an argument which will be the state change object from the store for that particular change. It needs to return an object which will then be mapped to the component state (similar to if that very returned object were used in the component's `setState`). If an object with no properties is returned then the component will *not* re-render. The mapping function is also called with its `this` keyword representing the component, so comparing store values to current component state values via `this.state` is possible as well.\r\n\r\n```javascript\r\nclass Counter extends Reflux.Component\r\n{\r\n    constructor(props) {\r\n        super(props);\r\n        this.mapStoreToState(MyStoreClass, function(fromStore){\r\n            var obj = {};\r\n            if (fromStore.color)\r\n                obj.color = fromStore.color;\r\n            if (fromStore.data && fromStore.data.classToUse)\r\n                obj.class = fromStore.data.classToUse;\r\n            return obj;\r\n        });\r\n    }\r\n    \r\n    render() {\r\n        return <p className={this.state.class}>The color is: {this.state.color}</p>;\r\n    }\r\n}\r\n```\r\n\r\nIn the above example `MyStoreClass` could have lots of state properties, but we use a bit of logic to 1) only trigger a re-render if the store's `state.color` or `state.data.classToUse` were among the parts of the state involved in the store's `setState` call (because, remember, if the returned object has no properties no re-render happens), and 2) to map the stores `state.color` straight to the component's `state.color`, but the store's `state.data.classToUse` to the component's `state.class`.\r\n\r\nNote that the example function above is merely that: an example. Whatever sort of logic you want to apply to get from the change object given by the store to how you want that to change the state of your component is fair game, except that you should not mutate the incoming data itself.\r\n\r\n### Utilizing Reflux.GlobalState\r\n\r\nAnother neat feature that the ES6 implementation of Reflux has is the ability to track a global state of all stores in use, as well as initialize all stores in use to a predefined global state. It happens internally too, so you don't have to do hardly anything to make it happen. This would be useful for many things, including tracking the state of an application and going back to that same state the next time the app is used.\r\n\r\nTo make it happen you just have to use ES6 style reflux classes and stores like explained in the last couple sections and define a static `id` property in your `Reflux.Store` definition. That id will then be used as a property name within the `Reflux.GlobalState` object for the property holding that store's current state. Then you just need to make sure to use `setState` to modify the state of the `Reflux.Store` instead of mutating the state directly. After that the `Reflux.GlobalState` object will reflect a collection of all your stores at all times once the components using those stores are mounted. An example using the example above:\r\n\r\n```javascript\r\nclass CounterStore extends Reflux.Store\r\n{\r\n    constructor() {\r\n        super();\r\n        this.listenables = Actions;\r\n        this.state = {count:0};\r\n    }\r\n    \r\n    onIncrement() {\r\n        var cnt = this.state.count;\r\n        this.setState({count:cnt+1});\r\n    }\r\n    \r\n    static get id() {\r\n        return 'counterstore';\r\n    }\r\n}\r\n\r\n// ... make component and render as normal ...\r\n\r\nconsole.log(Reflux.GlobalState); // <- would be: {'counterstore':{'count':0}}\r\n```\r\n\r\nNotice that you can only read the GlobalState **after** the components using the stores have been mounted. Up until then is the time where you can manually set the `Reflux.GlobalState` in order to initialize the entire app in a state of your choosing (or a previous state you recorded earlier). For example we could do this:\r\n\r\n```javascript\r\nclass CounterStore extends Reflux.Store\r\n{\r\n    constructor() {\r\n        super();\r\n        this.listenables = Actions;\r\n        this.state = {count:0};\r\n    }\r\n    \r\n    onIncrement() {\r\n        var cnt = this.state.count;\r\n        this.setState({count:cnt+1});\r\n    }\r\n    \r\n    static get id() {\r\n        return 'counterstore';\r\n    }\r\n}\r\n\r\nReflux.GlobalState = {'counterstore':{'count':50}};\r\n\r\n// ... make component and render as normal ...\r\n\r\n// at this point it would render with a count of 50!\r\n```\r\n\r\nOne of the most useful ways you could do this is to store a `Reflux.GlobalState` state as a JSON string in order to implement it again the next time the app starts up and have the user begin right where they left off.\r\n\r\n#### Reflux.setGlobalState and Reflux.getGlobalState\r\n\r\nDirectly accessing `Reflux.GlobalState` is a fine way to do set the starting state of an app and to do automated testing, but it is also helpful to be able to manipulate the global state while the app is running as well. To do this Reflux exposes a `Reflux.getGlobalState()` function and a `Reflux.setGlobalState()` function. The former allows you to get a deep copy of the current global state (so that the copy will not mutate as the global state itself continues to mutate) and the latter allows you to set part or all of the global state at any time in the program. Between these two functions things like state time-travel, undo/redo, and move-by-move tracking become relatively easy.\r\n\r\n### Making sure Reflux.Component is available\r\n\r\n`Reflux.Component` extends `React.Component`. Therefore Reflux needs to be able to access React in order to expose it. In the browser as long as React is loaded before Reflux then Reflux will automatically find it. Likewise in node-like environments where `require('react')` will function Reflux will try to access React that way. So in almost all situations Reflux will find React on its own.\r\n\r\nHowever, Reflux also exposes the method `Reflux.defineReact` that you can use to manually give Reflux a reference to the React object in case you need to:\r\n\r\n```javascript\r\n// only needed if, for some reason, Reflux can't get reference to React:\r\nvar React = /* however you access React */;\r\nReflux.defineReact(React);\r\n// now Reflux.Component is accessible!\r\n```\r\n\r\n### Extending a 3rd Party Class\r\n\r\nSometimes 3rd party libraries will have their own class that extends `React.Component` that they require you to use. Reflux handles this by exposing the `Reflux.Component.extend` method. If you have such a 3rd party class you can pass that class to this method and it will return a version of `Reflux.Component` that extends it instead of extending `React.Component` directly. Example:\r\n\r\n```javascript\r\nimport {ThirdPartyComponent} from 'third-party';\r\n\r\nvar RefluxThirdPartyComponent = Reflux.Component.extend(ThirdPartyComponent);\r\n\r\nclass MyComponent extends RefluxThirdPartyComponent\r\n{\r\n    // ...\r\n}\r\n```\r\n\r\n[Back to top](#content)\r\n\r\n## Colophon\r\n\r\n[List of contributors](https://github.com/spoike/reflux/graphs/contributors) is available on Github.\r\n\r\nThis project is licensed under [BSD 3-Clause License](http://opensource.org/licenses/BSD-3-Clause). Copyright (c) 2014, Mikael Brassman.\r\n\r\nFor more information about the license for this particular project [read the LICENSE.md file](LICENSE.md).\r\n\r\nThis project uses [eventemitter3](https://github.com/3rd-Eden/EventEmitter3), which [is currently MIT licensed](https://github.com/3rd-Eden/EventEmitter3/blob/master/LICENSE).\r\n\r\n[npm-image]: http://img.shields.io/npm/v/reflux.svg\r\n[downloads-image]: http://img.shields.io/npm/dm/reflux.svg\r\n[dependencies-image]: http://img.shields.io/david/reflux/refluxjs.svg\r\n[npm-url]: https://www.npmjs.org/package/reflux\r\n[bower-image]: http://img.shields.io/bower/v/reflux.svg\r\n[bower-url]: http://bower.io/search/?q=reflux\r\n[travis-image]: http://img.shields.io/travis/reflux/refluxjs/master.svg\r\n[travis-url]: https://travis-ci.org/reflux/refluxjs\r\n[gratipay-image]: http://img.shields.io/gratipay/spoike.svg\r\n[gratipay-url]: https://gratipay.com/spoike/\r\n[thinkful-image]: https://tf-assets-staging.s3.amazonaws.com/badges/thinkful_repo_badge.svg\r\n[thinkful-url]: http://start.thinkful.com/react/?utm_source=github&utm_medium=badge&utm_campaign=reflux\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/reflux/refluxjs.git"
  },
  "scripts": {
    "benchmark": "node test/benchmarks",
    "build": "grunt build",
    "test": "grunt test",
    "test:sauce": "grunt karma:sauce"
  },
  "version": "5.0.4"
}
